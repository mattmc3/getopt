// cmd/gen_flagfuncs/main.go
package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const fileTemplate = `// GENERATED - DO NOT EDIT.
// Code generated by gen_flagfuncs using 'go generate'

// These functions only differ from the builin flags.FlagSet ones in that
// they set the new []flags slice to preserve insertion order.

package getopt

import (
	"encoding"
	"flag"
	"time"
)

`

const methodTemplate = `{{.Doc}}func (f *FlagSet) {{.Name}}{{.Signature}} {
{{if .HasReturn}}	result := f.FlagSet.{{.Name}}({{.Params}})
{{if .HasName}}	f.flags = append(f.flags, f.FlagSet.Lookup(name))
{{end}}	return result
{{else}}	f.FlagSet.{{.Name}}({{.Params}})
{{if .HasName}}	f.flags = append(f.flags, f.FlagSet.Lookup(name))
{{end}}{{end}}}

`

func main() {
	fset := token.NewFileSet()
	flagSrc := filepath.Join(build.Default.GOROOT, "src", "flag", "flag.go")

	f, err := parser.ParseFile(fset, flagSrc, nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	buf.WriteString(fileTemplate)

	tmpl := template.Must(template.New("method").Parse(methodTemplate))

	// Find and generate methods
	ast.Inspect(f, func(n ast.Node) bool {
		fn, ok := n.(*ast.FuncDecl)
		if !ok || fn.Recv == nil {
			return true
		}

		// Check if it's a *FlagSet method
		if star, ok := fn.Recv.List[0].Type.(*ast.StarExpr); ok {
			if ident, ok := star.X.(*ast.Ident); ok && ident.Name == "FlagSet" && shouldGenerate(fn.Name.Name) {
				generateMethod(&buf, fset, fn, tmpl)
			}
		}
		return true
	})

	// Format & write
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Println("Format error:")
		fmt.Println(buf.String())
		panic(err)
	}

	os.WriteFile("getopt_gen.go", formatted, 0644)
	fmt.Println("Generated getopt_gen.go")
}

func shouldGenerate(name string) bool {
	return strings.HasSuffix(name, "Var") ||
		name == "Bool" || name == "String" || name == "Int" ||
		name == "Duration" || name == "Float64"
}

func generateMethod(buf *bytes.Buffer, fset *token.FileSet, method *ast.FuncDecl, tmpl *template.Template) {
	var doc string
	if method.Doc != nil {
		for _, comment := range method.Doc.List {
			doc += comment.Text + "\n"
		}
	}

	var sigBuf bytes.Buffer
	printer.Fprint(&sigBuf, fset, method.Type)
	signature := sigBuf.String()

	// Fix "Value" -> "flag.Value" and remove "func" prefix from signature
	signature = strings.ReplaceAll(signature, "(value Value,", "(value flag.Value,")
	signature = strings.TrimPrefix(signature, "func")

	var params []string
	hasName := false
	if method.Type.Params != nil {
		for _, field := range method.Type.Params.List {
			for _, name := range field.Names {
				params = append(params, name.Name)
				hasName = hasName || name.Name == "name"
			}
		}
	}

	tmpl.Execute(buf, map[string]interface{}{
		"Doc":       doc,
		"Name":      method.Name.Name,
		"Signature": signature,
		"Params":    strings.Join(params, ", "),
		"HasReturn": method.Type.Results != nil && len(method.Type.Results.List) > 0,
		"HasName":   hasName,
	})
}
