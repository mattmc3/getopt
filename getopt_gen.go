// GENERATED - DO NOT EDIT.
// Code generated by gen_flagfuncs using 'go generate'

// These functions only differ from the builin flags.FlagSet ones in that
// they set the new []flags slice to preserve insertion order.

package getopt

import (
	"encoding"
	"flag"
	"time"
)

// BoolVar defines a bool flag with specified name, default value, and usage string.
// The argument p points to a bool variable in which to store the value of the flag.
func (f *FlagSet) BoolVar(p *bool, name string, value bool, usage string) {
	f.FlagSet.BoolVar(p, name, value, usage)
	f.flags = append(f.flags, f.FlagSet.Lookup(name))
}

// Bool defines a bool flag with specified name, default value, and usage string.
// The return value is the address of a bool variable that stores the value of the flag.
func (f *FlagSet) Bool(name string, value bool, usage string) *bool {
	result := f.FlagSet.Bool(name, value, usage)
	f.flags = append(f.flags, f.FlagSet.Lookup(name))
	return result
}

// IntVar defines an int flag with specified name, default value, and usage string.
// The argument p points to an int variable in which to store the value of the flag.
func (f *FlagSet) IntVar(p *int, name string, value int, usage string) {
	f.FlagSet.IntVar(p, name, value, usage)
	f.flags = append(f.flags, f.FlagSet.Lookup(name))
}

// Int defines an int flag with specified name, default value, and usage string.
// The return value is the address of an int variable that stores the value of the flag.
func (f *FlagSet) Int(name string, value int, usage string) *int {
	result := f.FlagSet.Int(name, value, usage)
	f.flags = append(f.flags, f.FlagSet.Lookup(name))
	return result
}

// Int64Var defines an int64 flag with specified name, default value, and usage string.
// The argument p points to an int64 variable in which to store the value of the flag.
func (f *FlagSet) Int64Var(p *int64, name string, value int64, usage string) {
	f.FlagSet.Int64Var(p, name, value, usage)
	f.flags = append(f.flags, f.FlagSet.Lookup(name))
}

// UintVar defines a uint flag with specified name, default value, and usage string.
// The argument p points to a uint variable in which to store the value of the flag.
func (f *FlagSet) UintVar(p *uint, name string, value uint, usage string) {
	f.FlagSet.UintVar(p, name, value, usage)
	f.flags = append(f.flags, f.FlagSet.Lookup(name))
}

// Uint64Var defines a uint64 flag with specified name, default value, and usage string.
// The argument p points to a uint64 variable in which to store the value of the flag.
func (f *FlagSet) Uint64Var(p *uint64, name string, value uint64, usage string) {
	f.FlagSet.Uint64Var(p, name, value, usage)
	f.flags = append(f.flags, f.FlagSet.Lookup(name))
}

// StringVar defines a string flag with specified name, default value, and usage string.
// The argument p points to a string variable in which to store the value of the flag.
func (f *FlagSet) StringVar(p *string, name string, value string, usage string) {
	f.FlagSet.StringVar(p, name, value, usage)
	f.flags = append(f.flags, f.FlagSet.Lookup(name))
}

// String defines a string flag with specified name, default value, and usage string.
// The return value is the address of a string variable that stores the value of the flag.
func (f *FlagSet) String(name string, value string, usage string) *string {
	result := f.FlagSet.String(name, value, usage)
	f.flags = append(f.flags, f.FlagSet.Lookup(name))
	return result
}

// Float64Var defines a float64 flag with specified name, default value, and usage string.
// The argument p points to a float64 variable in which to store the value of the flag.
func (f *FlagSet) Float64Var(p *float64, name string, value float64, usage string) {
	f.FlagSet.Float64Var(p, name, value, usage)
	f.flags = append(f.flags, f.FlagSet.Lookup(name))
}

// Float64 defines a float64 flag with specified name, default value, and usage string.
// The return value is the address of a float64 variable that stores the value of the flag.
func (f *FlagSet) Float64(name string, value float64, usage string) *float64 {
	result := f.FlagSet.Float64(name, value, usage)
	f.flags = append(f.flags, f.FlagSet.Lookup(name))
	return result
}

// DurationVar defines a time.Duration flag with specified name, default value, and usage string.
// The argument p points to a time.Duration variable in which to store the value of the flag.
// The flag accepts a value acceptable to time.ParseDuration.
func (f *FlagSet) DurationVar(p *time.Duration, name string, value time.Duration, usage string) {
	f.FlagSet.DurationVar(p, name, value, usage)
	f.flags = append(f.flags, f.FlagSet.Lookup(name))
}

// Duration defines a time.Duration flag with specified name, default value, and usage string.
// The return value is the address of a time.Duration variable that stores the value of the flag.
// The flag accepts a value acceptable to time.ParseDuration.
func (f *FlagSet) Duration(name string, value time.Duration, usage string) *time.Duration {
	result := f.FlagSet.Duration(name, value, usage)
	f.flags = append(f.flags, f.FlagSet.Lookup(name))
	return result
}

// TextVar defines a flag with a specified name, default value, and usage string.
// The argument p must be a pointer to a variable that will hold the value
// of the flag, and p must implement encoding.TextUnmarshaler.
// If the flag is used, the flag value will be passed to p's UnmarshalText method.
// The type of the default value must be the same as the type of p.
func (f *FlagSet) TextVar(p encoding.TextUnmarshaler, name string, value encoding.TextMarshaler, usage string) {
	f.FlagSet.TextVar(p, name, value, usage)
	f.flags = append(f.flags, f.FlagSet.Lookup(name))
}

// Var defines a flag with the specified name and usage string. The type and
// value of the flag are represented by the first argument, of type [Value], which
// typically holds a user-defined implementation of [Value]. For instance, the
// caller could create a flag that turns a comma-separated string into a slice
// of strings by giving the slice the methods of [Value]; in particular, [Set] would
// decompose the comma-separated string into the slice.
func (f *FlagSet) Var(value flag.Value, name string, usage string) {
	f.FlagSet.Var(value, name, usage)
	f.flags = append(f.flags, f.FlagSet.Lookup(name))
}
